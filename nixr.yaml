substitutions:
  name: "nixr"
  friendly_name: "NIXR"
  time_zone: "Australia/Brisbane"

esphome:
  project:
    name: "NIXlabs.NIXR"
    version: "0.1"
  name: "${name}"
  friendly_name: "${friendly_name}"
  platformio_options:
    board_build.flash_mode: dio
  on_boot:
    - priority: 800
      then:
        - logger.log: 
            format: "Booting 123"
            level: DEBUG
        - lambda: 'id(RingClock)->set_state(ring_clock::state::booting);'
    - priority: 300
      then:
        - logger.log: 
            format: "Starting Time Display"
            level: DEBUG
        - pcf8563.read_time:
              id: rtc_time
        - light.turn_on:
            id: ring_light
            brightness: !lambda 'return id(standard_percentage)->state/100;'
            effect: Clock
  on_shutdown:
    - priority: 700
      then:
        - lambda: 'id(RingClock)->set_state(ring_clock::state::shutdown);'

esp32:
  board: esp32-c3-devkitm-1
  variant: ESP32C3
  framework:
    type: esp-idf

# Enable logging
logger:
  level: DEBUG
  logs:
    sensor: INFO
    datetime.datetime_entity: INFO

# Enable Home Assistant API
api:

ota:
  - platform: http_request
  - platform: web_server
  - platform: esphome

http_request:

update:
  - platform: http_request
    name: Firmware Update
    source: https://raw.githubusercontent.com/nix-labs/esp-firmware/latest/manifest.json
    update_interval: 60s

wifi:
  power_save_mode: none
  # Set up a wifi access point
  ap:
    password: "12345678"

captive_portal:

# Sets up Bluetooth LE (Only on ESP32) to allow the user
# to provision wifi credentials to the device.
esp32_improv:
  authorizer: none

# Sets up the improv via serial client for Wi-Fi provisioning
improv_serial:

# This should point to the public location of this yaml file.
dashboard_import:
  package_import_url: github://n33174/nixr_dev/nixr.yaml@main
  import_full_config: false # or true

external_components:
  - source: github://n33174/nixr_dev@main
    components: [ring_clock]

globals:
  - id: minute_button_long_press
    type: bool
    initial_value: 'false'
  - id: hour_button_long_press
    type: bool
    initial_value: 'false'

web_server:
  port: 80
  version: 3
  sorting_groups:
    - id: sorting_time
      name: "Time Settings"
      sorting_weight: 10
    - id: sorting_light
      name: "Light settings"
      sorting_weight: 20
    - id: sorting_sensors
      name: "Sensors"
      sorting_weight: 30
    - id: sorting_other
      name: "Other"
      sorting_weight: 40
    - id: sorting_system
      name: "System"
      sorting_weight: 50

ring_clock:
  id: RingClock
  time_id: rtc_time
  light_id: ring_light
  enable_scale: enable_scale
  enable_seconds: enable_seconds
  hour_hand_color: hour_hand_color
  minute_hand_color: minute_hand_color
  second_hand_color: second_hand_color
  scale_color: scale_color
  notification_color: notification_color
  on_ready:
    then:
      - light.turn_on:
          id: ring_light
          brightness: !lambda 'return id(standard_percentage)->state/100;'
          effect: Clock

i2c:
  scl: GPIO5
  sda: GPIO6
  scan: true

uart:
  id: uart_bus
  baud_rate:  256000
  tx_pin: GPIO0
  rx_pin: GPIO1
  parity: NONE
  stop_bits: 1

ld2410:

binary_sensor:
  - platform: ld2410
    has_target:
      name: Occupancy
      web_server:
        sorting_group_id: sorting_sensors
      on_press:
        - if:
            condition:
              - switch.is_on: presense_detection
            then:
              - light.turn_on:
                  id: ring_light
                  brightness:  !lambda 'return id(standard_percentage)->state/100;'
                  transition_length: 1s
      on_release:
        - if:
            condition:
              - switch.is_on: presense_detection
            then:
              - light.turn_on:
                  id: ring_light
                  brightness:  !lambda 'return id(low_percentage)->state/100;'
                  transition_length: 1s
    has_moving_target:
      name: Moving Target
      web_server:
        sorting_group_id: sorting_sensors
    has_still_target:
      name: Still Target
      web_server:
        sorting_group_id: sorting_sensors
  - platform: gpio
    pin: GPIO3
    name: "Presence"
    device_class: presence
  - platform: gpio
    pin:
      number: GPIO2
      inverted: True
      mode: INPUT_PULLUP
    name: "Mode Button"
    internal: true
    filters:
      delayed_on_off: 100ms # Debouncing
    on_press: 
      then:
        - switch.toggle: presense_detection
        - if:
            condition:
              - switch.is_on: presense_detection
            then:
              - rtttl.play: 'double:d=4,o=5,b=100:16e6,16e6'
            else:
              - rtttl.play: 'single:d=4,o=5,b=100:16e6'
  - platform: gpio
    pin:
      number: GPIO8
      inverted: True
      mode: INPUT_PULLUP
    name: "Hour Button"
    internal: true
    filters:
      - delayed_on: 20ms
      - delayed_off: 20ms
    on_multi_click:
      - timing:
          - ON for 40ms to 1s
          - OFF for at least 50ms
        then:
         - button.press: hour_increment
      - timing:
          - ON for at least 1s
        then:
          lambda: |-
            id(hour_button_long_press) = true;
      - timing:
          - OFF for at least 50ms
        then:
          lambda: |-
            id(hour_button_long_press) = false;
  - platform: gpio
    pin:
      number: GPIO9
      inverted: True
      mode: INPUT_PULLUP
    name: "Minute Button"
    internal: true
    filters:
      - delayed_on: 20ms
      - delayed_off: 20ms
    on_multi_click:
      - timing:
          - ON for 40ms to 1s
          - OFF for at least 50ms
        then:
         - button.press: minute_increment
      - timing:
          - ON for at least 1s
        then:
          lambda: |-
            id(minute_button_long_press) = true;
      - timing:
          - OFF for at least 50ms
        then:
          lambda: |-
            id(minute_button_long_press) = false;

interval:
  - interval: 250ms
    then:
      lambda: |-
        if (id(minute_button_long_press)) {
          id(minute_increment)->press();
        }
        if (id(hour_button_long_press)) {
          id(hour_increment)->press();
        }

sensor:
  - platform: aht10
    variant: AHT20
    address: 0x38
    temperature:
      name: Temperature
      web_server:
        sorting_group_id: sorting_sensors
    humidity:
      name: Humidity
      web_server:
        sorting_group_id: sorting_sensors
  - platform: adc
    pin: GPIO4
    name: "Brightness"
    id: brightness_sensor
    icon: mdi:brightness-6
    accuracy_decimals: 0
    web_server:
      sorting_group_id: sorting_sensors
    attenuation: 12db
    update_interval: 5s
    unit_of_measurement: "%"
    filters:
      - calibrate_linear:
          - 0.0 -> 0.0
          - 3.0 -> 100.0
      - lambda: |-
          float interference = id(RingClock)->get_interference_factor();
          
          // 1. Subtract the additive bleed (approx 35% per full capped LED)
          float clean_value = x - (interference * 35.0f);
          
          // 2. Multiplicative adjustment to restore range (approx 1.5x)
          float adjusted_value = clean_value * (1.0f + interference * 0.5f);
          
          return adjusted_value < 0 ? 0 : (adjusted_value > 100 ? 100 : adjusted_value);
      - sliding_window_moving_average:
          window_size: 5
          send_every: 1

text:
  - platform: template
    name: "Time Zone"
    id: time_zone
    mode: text
    optimistic: true
    initial_value: ${time_zone}
    web_server:
      sorting_group_id: sorting_time

number:
  - platform: template
    id: standard_percentage
    name: "Standard Brightness Percentage"
    optimistic: True
    restore_value: True
    unit_of_measurement: "%"
    initial_value: 50
    min_value: 1
    max_value: 100
    step: 1
    web_server:
      sorting_group_id: sorting_light
  - platform: template
    id: low_percentage
    name: "Low/Off Brightness Percentage"
    optimistic: True
    restore_value: True
    unit_of_measurement: "%"
    initial_value: 25
    min_value: 1
    max_value: 100
    step: 1
    web_server:
      sorting_group_id: sorting_light

button:
  - platform: restart
    name: Restart
    id: restart_esp
    web_server:
      sorting_group_id: sorting_system
  - platform: factory_reset
    name: Reset with Default Settings
    disabled_by_default: True
    web_server:
      sorting_group_id: sorting_system
  - platform: template
    name: Buzzer
    web_server:
      sorting_group_id: sorting_other
    on_press: 
      then:
        - rtttl.play: siren:d=8,o=5,b=100:d,e,d,e,d,e,d,e
  - platform: template
    name: "Hour Increment"
    id: hour_increment
    web_server:
      sorting_group_id: sorting_time
    on_press:
      then:
        - rtttl.play: 'short:d=4,o=5,b=100:16e6'
        - switch.turn_off: sntp_switch
        - if:
            condition:
              time.has_time:
                id: rtc_time
            then:
              - datetime.datetime.set:
                    id: custom_time
                    datetime: !lambda 'return id(rtc_time).now();'
        - lambda: |-
            setenv("TZ", id(time_zone)->state.c_str(), 1);
            tzset();
            struct tm time_info;
            auto *time = id(custom_time); // Get TemplateDateTime pointer
            time_info.tm_year = time->year - 1900;
            time_info.tm_mon = time->month - 1;
            time_info.tm_mday = time->day;
            time_info.tm_hour = time->hour + 1;
            time_info.tm_min = time->minute;
            time_info.tm_sec = time->second;
            time_info.tm_isdst = -1;
            std::time_t t = mktime(&time_info);
            struct timeval tv = {t, 0};
            settimeofday(&tv, NULL);
            ESP_LOGD("main", "System time set to: %s", ctime(&t));
        - pcf8563.write_time:
            id: rtc_time
        - datetime.datetime.set:
              id: custom_time
              datetime: !lambda |-
                  auto time = id(rtc_time).now();
                  return time;
        - logger.log: 
            format: "RTC incremented by 1 hour"
            level: INFO
  - platform: template
    name: "Minute Increment"
    id: minute_increment
    web_server:
      sorting_group_id: sorting_time
    on_press:
      then:
        - rtttl.play: 'short:d=4,o=5,b=100:16e6'
        - switch.turn_off: sntp_switch
        - if:
            condition:
              time.has_time:
                id: rtc_time
            then:
              - datetime.datetime.set:
                    id: custom_time
                    datetime: !lambda 'return id(rtc_time).now();'
        - lambda: |-
            setenv("TZ", id(time_zone)->state.c_str(), 1);
            tzset();
            struct tm time_info;
            auto *time = id(custom_time);
            time_info.tm_year = time->year - 1900;
            time_info.tm_mon = time->month - 1;
            time_info.tm_mday = time->day;
            time_info.tm_hour = time->hour;
            time_info.tm_min = time->minute + 1;
            time_info.tm_sec = time->second;
            time_info.tm_isdst = -1;
            std::time_t t = mktime(&time_info);
            struct timeval tv = {t, 0};
            settimeofday(&tv, NULL);
            ESP_LOGD("main", "System time set to: %s", ctime(&t));
        - pcf8563.write_time:
            id: rtc_time
        - datetime.datetime.set:
              id: custom_time
              datetime: !lambda |-
                  auto time = id(rtc_time).now();
                  return time;
        - logger.log: 
            format: "RTC incremented by 1 minute"
            level: INFO
  - platform: template
    name: "Set Custom Time"
    id: custom_sync
    web_server:
      sorting_group_id: sorting_time
    on_press:
      then:
        - if:
            condition:
              - switch.is_off: sntp_switch
            then:
              - lambda: |-
                  setenv("TZ", id(time_zone)->state.c_str(), 1);
                  tzset();
                  struct tm time_info;
                  auto *time = id(custom_time);
                  time_info.tm_year = time->year - 1900;
                  time_info.tm_mon = time->month - 1;
                  time_info.tm_mday = time->day;
                  time_info.tm_hour = time->hour;
                  time_info.tm_min = time->minute;
                  time_info.tm_sec = time->second;
                  time_info.tm_isdst = -1;
                  std::time_t t = mktime(&time_info);
                  struct timeval tv = {t, 0};
                  settimeofday(&tv, NULL);
                  ESP_LOGD("main", "System time set to: %s", ctime(&t));
              - pcf8563.write_time:
                  id: rtc_time
              - logger.log: 
                  format: "RTC updated with custom time"
                  level: INFO
            else:
              - logger.log:
                  format: "Custom time NOT set - SNTP sync active"
                  level: WARN

switch:
  - platform: template
    name: "Enable SNTP Sync"
    id: sntp_switch
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_time
  - platform: template
    name: "Presense Detection Dimming"
    id: presense_detection
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF
    web_server:
      sorting_group_id: sorting_light
  - platform: template
    name: "Enable Seconds"
    id: enable_seconds
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_light
  - platform: template
    name: "Enable Scale"
    id: enable_scale
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_light


datetime:
  - platform: template
    name: "Custom Time"
    id: custom_time
    type: datetime
    initial_value: "2025-01-01 12:00:00"
    optimistic: True
    web_server:
      sorting_group_id: sorting_time


time:
  - platform: pcf8563
    address: 0x51
    update_interval: never
    id: rtc_time
    on_time:
      - seconds: 0
        minutes: /1
        then:
          - datetime.datetime.set:
              id: custom_time
              datetime: !lambda |-
                  auto time = id(rtc_time).now();
                  return time;

  - platform: sntp
    id: sntp_time
    on_time_sync:
      then:
        - if:
            condition:
              - switch.is_on: sntp_switch
            then:
              - pcf8563.write_time:
                  id: rtc_time
              - logger.log: 
                  format: "SNTP Time Synchronised and RTC updated"
                  level: INFO

light:
  # Main LED Rings
  - id: ring_light
    name: "Ring Light"
    platform: esp32_rmt_led_strip
    rgb_order: GRB
    chipset: ws2812
    pin: GPIO10
    num_leds: 108
    gamma_correct: 2.2
    # WARNING Increasing the values above 75% will exceed the devices electrical current limits and may cause overheating and physical damage
    color_correct: [75%, 75%, 75%]
    web_server:
      sorting_group_id: sorting_light
    effects:
      - addressable_lambda:
          name: Clock
          update_interval: 50ms
          lambda: |-
            id(RingClock)->set_state(ring_clock::state::time);
            id(RingClock)->addressable_lights_lambdacall(it);
      - addressable_lambda:
          name: "Clock (Fade)"
          update_interval: 33ms
          lambda: |-
            id(RingClock)->set_state(ring_clock::state::time_fade);
            id(RingClock)->addressable_lights_lambdacall(it);
      - addressable_lambda:
          name: "Clock (Rainbow)"
          update_interval: 33ms
          lambda: |-
            id(RingClock)->set_state(ring_clock::state::time_rainbow);
            id(RingClock)->addressable_lights_lambdacall(it);
  # Customise Hour Hand
  - platform: rgb
    id: hour_hand_color
    name: "Hour Hand"
    restore_mode: RESTORE_DEFAULT_OFF
    default_transition_length: 0s
    red: output_hour_red
    green: output_hour_green
    blue: output_hour_blue
    web_server:
      sorting_group_id: sorting_light
  # Customise Minute Hand
  - platform: rgb
    id: minute_hand_color
    name: "Minute Hand"
    restore_mode: RESTORE_DEFAULT_OFF
    default_transition_length: 0s
    red: output_minute_red
    green: output_minute_green
    blue: output_minute_blue
    web_server:
      sorting_group_id: sorting_light
  # Customise Second Hand
  - platform: rgb
    id: second_hand_color
    name: "Second Hand"
    restore_mode: RESTORE_DEFAULT_OFF
    default_transition_length: 0s
    red: output_second_red
    green: output_second_green
    blue: output_second_blue
    web_server:
      sorting_group_id: sorting_light
  # Customise Scale
  - platform: rgb
    id: scale_color
    name: "Scale"
    restore_mode: RESTORE_DEFAULT_OFF
    default_transition_length: 1s
    red: output_scale_red
    green: output_scale_green
    blue: output_scale_blue
    web_server:
      sorting_group_id: sorting_light
    effects:
      - random:
  # Remaining Inner Ring LEDs
  - platform: rgb
    id: notification_color
    name: "Notification"
    restore_mode: RESTORE_DEFAULT_OFF
    default_transition_length: 1s
    red: output_notification_red
    green: output_notification_green
    blue: output_notification_blue
    web_server:
      sorting_group_id: sorting_light
    effects:
      - random:
      - pulse:
          name: "Fast Pulse"
          transition_length: 0.5s
          update_interval: 0.5s
          min_brightness: 50%
          max_brightness: 100%
      - pulse:
          name: "Slow Pulse"
          transition_length: 500ms
          update_interval: 2s

output:
  # Dummy LED Outputs
  - platform: template
    id: output_hour_red
    type: float
    write_action: {}
  - platform: template
    id: output_hour_green
    type: float
    write_action: {}
  - platform: template
    id: output_hour_blue
    type: float
    write_action: {}
  - platform: template
    id: output_minute_red
    type: float
    write_action: {}
  - platform: template
    id: output_minute_green
    type: float
    write_action: {}
  - platform: template
    id: output_minute_blue
    type: float
    write_action: {}
  - platform: template
    id: output_second_red
    type: float
    write_action: {}
  - platform: template
    id: output_second_green
    type: float
    write_action: {}
  - platform: template
    id: output_second_blue
    type: float
    write_action: {}
  - platform: template
    id: output_scale_red
    type: float
    write_action: {}
  - platform: template
    id: output_scale_green
    type: float
    write_action: {}
  - platform: template
    id: output_scale_blue
    type: float
    write_action: {}
  - platform: template
    id: output_notification_red
    type: float
    write_action: {}
  - platform: template
    id: output_notification_green
    type: float
    write_action: {}
  - platform: template
    id: output_notification_blue
    type: float
    write_action: {}
  #Buzzer Output  
  - platform: ledc
    pin: GPIO7
    id: buzzer

rtttl:
  output: buzzer
  id: buzzer_rtttl
  gain: 90%
