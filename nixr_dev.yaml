substitutions:
  name: "al60"
  friendly_name: "NIX labs AL60 Clock"
  time_zone: "Australia/Brisbane"

esphome:
  project:
    name: "NIXlabs.AL60"
    version: "0.1.2"
  name: "${name}"
  friendly_name: "${friendly_name}"
  platformio_options:
    board_build.flash_mode: dio
  on_boot:
    - priority: 800
      then:
        - logger.log: 
            format: "Booting 123"
            level: DEBUG
        - lambda: 'id(RingClock)->set_state(ring_clock::state::booting);'

    - priority: 300
      then:
        - logger.log: 
            format: "Starting Time Display"
            level: DEBUG
        - pcf8563.read_time:
              id: rtc_time
        - lambda: |-
            auto call = id(ring_light).turn_on();
            call.set_brightness(id(standard_percentage).state / 100.0f);
            call.set_effect(id(last_clock_effect));
            call.perform();
  on_shutdown:
    - priority: 700
      then:
        - lambda: 'id(RingClock)->set_state(ring_clock::state::shutdown);'

esp32:
  board: esp32-c3-devkitm-1
  variant: ESP32C3
  framework:
    type: esp-idf

# Enable logging
logger:
  level: DEBUG
  logs:
    sensor: INFO
    datetime.datetime_entity: INFO

# Enable Home Assistant API
api:
  encryption:
    key: "jYr77i2VI8BEcxGuhQvnX9RpRumx7WCYoZVv4piHWxI="
  # Confirm this setting
  reboot_timeout: 0s

ota:
  - platform: http_request
  - platform: web_server
  - platform: esphome
    password: "59ddefdfc18e3fa945ca6e45eb73ef47"
    
http_request:

update:
  - platform: http_request
    name: Firmware Update
    source: https://raw.githubusercontent.com/nix-labs/esp-firmware/latest/manifest.json

wifi:
  power_save_mode: none
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  reboot_timeout: 0s

  manual_ip:
    static_ip: 192.168.20.57
    gateway: 192.168.20.1
    subnet: 255.255.255.0
    dns1: 192.168.20.1

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "AL60 Fallback Hotspot"
    password: "SPt0OFUb7nPR"

captive_portal:

external_components:
  - source: github://n33174/nixr_dev@main
    components: [ ring_clock ]
    refresh: 1s

globals:
  - id: minute_button_long_press
    type: bool
    initial_value: 'false'
  - id: hour_button_long_press
    type: bool
    initial_value: 'false'
  - id: last_clock_effect
    type: std::string
    restore_value: yes
    initial_value: '"Clock"'

web_server:
  port: 80
  version: 3
  css_url: https://raw.githack.com/n33174/nixr_dev/main/style/web_server.css
  sorting_groups:
    - id: sorting_time
      name: "Time Settings"
      sorting_weight: 10
    - id: sorting_clock
      name: "Clock Settings"
      sorting_weight: 20
    - id: sorting_clock_led
      name: "Clock LED Customisation"
      sorting_weight: 25
    - id: sorting_sensors
      name: "Sensors"
      sorting_weight: 30
    - id: sorting_other
      name: "Other"
      sorting_weight: 40
    - id: sorting_timer
      name: "Timer & Stopwatch"
      sorting_weight: 45
    - id: sorting_alarm
      name: "Alarm"
      sorting_weight: 46
    - id: sorting_system
      name: "System"
      sorting_weight: 50

ring_clock:
  id: RingClock
  time_id: rtc_time
  light_id: ring_light
  enable_markers: enable_markers
  enable_seconds: enable_seconds
  hour_hand_color: hour_hand_color
  minute_hand_color: minute_hand_color
  second_hand_color: second_hand_color
  marker_color: marker_color
  notification_color: notification_color
  sound_enabled_switch: timer_sounds
  temperature_sensor: temp_sensor
  humidity_sensor: humidity_sensor
  on_ready:
    then:
      - lambda: |-
          auto call = id(ring_light).turn_on();
          call.set_brightness(id(standard_percentage).state / 100.0f);
          call.set_effect(id(last_clock_effect));
          call.perform();
  on_alarm_triggered:
    then:
      - if:
          condition:
            - switch.is_on: alarm_sound
          then:
            - rtttl.play: "alarm:d=16,o=6,b=140:c,e,g,c7,g,e,c,g,e,g,b,e7,b,g,e,b,4c7,p,4c7,p,4c7,p"
  on_timer_finished:
    then:
      - rtttl.play: "timer_alert:d=16,o=6,b=120:c,e,g,c7,p,g,e,c,p,c,e,g,c7,p,g,e,c,p,8c7,p,8c7,p,8c7"
      - delay: 10s
      - lambda: |-
          auto call = id(ring_light).turn_on();
          call.set_effect(id(last_clock_effect));
          call.perform();
  on_stopwatch_minute:
    then:
      - rtttl.play: "chime:d=16,o=6,b=120:c"
  on_timer_started:
    then:
      - rtttl.play: "timer_start:d=16,o=6,b=120:c,e,g"
  on_timer_stopped:
    then:
      - rtttl.play: "timer_stop:d=16,o=6,b=120:g,e,c"
  on_stopwatch_started:
    then:
      - rtttl.play: "sw_start:d=16,o=6,b=120:c7"
  on_stopwatch_paused:
    then:
      - rtttl.play: "sw_pause:d=16,o=6,b=120:c7,p,c7"
  on_stopwatch_reset:
    then:
      - rtttl.play: "sw_reset:d=16,o=6,b=120:c,d,e,f,g"

i2c:
  scl: GPIO5
  sda: GPIO6
  scan: true

uart:
  id: uart_bus
  baud_rate:  256000
  tx_pin: GPIO0
  rx_pin: GPIO1
  parity: NONE
  stop_bits: 1

ld2410:

binary_sensor:
  - platform: ld2410
    has_target:
      name: Occupancy
      web_server:
        sorting_group_id: sorting_sensors
      on_press:
        - if:
            condition:
              - switch.is_on: presense_detection
            then:
              - light.turn_on:
                  id: ring_light
                  brightness:  !lambda 'return id(standard_percentage)->state/100;'
                  transition_length: 1s
      on_release:
        - if:
            condition:
              - switch.is_on: presense_detection
            then:
              - light.turn_on:
                  id: ring_light
                  brightness:  !lambda 'return id(low_percentage)->state/100;'
                  transition_length: 1s
    has_moving_target:
      name: Moving Target
      web_server:
        sorting_group_id: sorting_sensors
    has_still_target:
      name: Still Target
      web_server:
        sorting_group_id: sorting_sensors
  - platform: gpio
    pin: GPIO3
    name: "Presence"
    web_server:
      sorting_group_id: sorting_sensors
    device_class: presence
  - platform: gpio
    pin:
      number: GPIO2
      inverted: True
      mode: INPUT_PULLUP
    name: "Mode Button"
    internal: true
    filters:
      delayed_on_off: 100ms # Debouncing
    on_press: 
      then:
        - switch.toggle: presense_detection
        - if:
            condition:
              - switch.is_on: presense_detection
            then:
              - rtttl.play: 'double:d=4,o=5,b=100:16e6,16e6'
            else:
              - rtttl.play: 'single:d=4,o=5,b=100:16e6'
  - platform: gpio
    pin:
      number: GPIO8
      inverted: True
      mode: INPUT_PULLUP
    name: "Hour Button"
    internal: true
    filters:
      - delayed_on: 20ms
      - delayed_off: 20ms
    on_multi_click:
      - timing:
          - ON for 40ms to 1s
          - OFF for at least 50ms
        then:
         - button.press: hour_increment
      - timing:
          - ON for at least 1s
        then:
          lambda: |-
            id(hour_button_long_press) = true;
      - timing:
          - OFF for at least 50ms
        then:
          lambda: |-
            id(hour_button_long_press) = false;
  - platform: gpio
    pin:
      number: GPIO9
      inverted: True
      mode: INPUT_PULLUP
    name: "Minute Button"
    internal: true
    filters:
      - delayed_on: 20ms
      - delayed_off: 20ms
    on_multi_click:
      - timing:
          - ON for 40ms to 1s
          - OFF for at least 50ms
        then:
         - button.press: minute_increment
      - timing:
          - ON for at least 1s
        then:
          lambda: |-
            id(minute_button_long_press) = true;
      - timing:
          - OFF for at least 50ms
        then:
          lambda: |-
            id(minute_button_long_press) = false;

interval:
  - interval: 250ms
    then:
      lambda: |-
        if (id(minute_button_long_press)) {
          id(minute_increment)->press();
        }
        if (id(hour_button_long_press)) {
          id(hour_increment)->press();
        }

sensor:
  - platform: aht10
    variant: AHT20
    address: 0x38
    temperature:
      id: temp_sensor
      name: Temperature
      icon: mdi:thermometer
      web_server:
        sorting_group_id: sorting_sensors
    humidity:
      id: humidity_sensor
      name: Humidity
      icon: mdi:water-percent
      web_server:
        sorting_group_id: sorting_sensors
  - platform: adc
    pin: GPIO4
    name: "Brightness"
    id: brightness_sensor
    icon: mdi:brightness-6
    accuracy_decimals: 0
    web_server:
      sorting_group_id: sorting_sensors
    attenuation: 12db
    update_interval: 5s
    unit_of_measurement: "%"
    filters:
      - calibrate_linear:
          - 0.0 -> 0.0
          - 3.0 -> 100.0
      - lambda: |-
          float interference = id(RingClock)->get_interference_factor();
          
          // Multiplicative adjustment (as a divisor/factor)
          // Using a softer weight of 1.8 to reflect the "slightly less" request
          float factor = 1.0f / (1.0f + (interference * 1.8f));
          
          float adjusted_value = x * factor;
          
          return adjusted_value < 0 ? 0 : (adjusted_value > 100 ? 100 : adjusted_value);
      - sliding_window_moving_average:
          window_size: 5
          send_every: 1

text:
  - platform: template
    name: "Time Zone"
    id: time_zone
    mode: text
    optimistic: true
    initial_value: ${time_zone}
    web_server:
      sorting_group_id: sorting_time

number:
  - platform: template
    id: standard_percentage
    name: "Standard Brightness Percentage"
    optimistic: True
    restore_value: True
    unit_of_measurement: "%"
    initial_value: 50
    min_value: 1
    max_value: 100
    step: 1
    web_server:
      sorting_group_id: sorting_clock
  - platform: template
    id: low_percentage
    name: "Low or Off Brightness Percentage"
    optimistic: True
    restore_value: True
    unit_of_measurement: "%"
    initial_value: 25
    min_value: 1
    max_value: 100
    step: 1
    web_server:
      sorting_group_id: sorting_clock

  - platform: template
    name: "Timer Hours"
    id: timer_hours
    min_value: 0
    max_value: 12
    step: 1
    initial_value: 0
    optimistic: True
    web_server:
      sorting_group_id: sorting_timer
  - platform: template
    name: "Timer Minutes"
    id: timer_minutes
    min_value: 0
    max_value: 59
    step: 1
    initial_value: 0
    optimistic: True
    web_server:
      sorting_group_id: sorting_timer
  - platform: template
    name: "Timer Seconds"
    id: timer_seconds
    min_value: 0
    max_value: 59
    step: 1
    initial_value: 0
    optimistic: True
    web_server:
      sorting_group_id: sorting_timer

button:
  - platform: restart
    name: Restart
    id: restart_esp
    web_server:
      sorting_group_id: sorting_system
  - platform: factory_reset
    name: Reset with Default Settings
    disabled_by_default: True
    web_server:
      sorting_group_id: sorting_system
  - platform: template
    name: Buzzer
    web_server:
      sorting_group_id: sorting_other
    on_press: 
      then:
        - rtttl.play: notification:d=16,o=6,b=160:c,e,g,c7
  - platform: template
    name: "Hour Increment"
    id: hour_increment
    web_server:
      sorting_group_id: sorting_time
    on_press:
      then:
        - rtttl.play: 'short:d=4,o=5,b=100:16e6'
        - switch.turn_off: sntp_switch
        - if:
            condition:
              time.has_time:
                id: rtc_time
            then:
              - datetime.datetime.set:
                    id: custom_time
                    datetime: !lambda 'return id(rtc_time).now();'
        - lambda: |-
            setenv("TZ", id(time_zone)->state.c_str(), 1);
            tzset();
            struct tm time_info;
            auto *time = id(custom_time);
            time_info.tm_year = time->year - 1900;
            time_info.tm_mon = time->month - 1;
            time_info.tm_mday = time->day;
            time_info.tm_hour = time->hour + 1;
            time_info.tm_min = time->minute;
            time_info.tm_sec = time->second;
            time_info.tm_isdst = -1;
            std::time_t t = mktime(&time_info);
            struct timeval tv = {t, 0};
            settimeofday(&tv, NULL);
            ESP_LOGD("main", "System time set to: %s", ctime(&t));
        - pcf8563.write_time:
            id: rtc_time
        - datetime.datetime.set:
              id: custom_time
              datetime: !lambda |-
                  auto time = id(rtc_time).now();
                  return time;
        - logger.log: 
            format: "RTC incremented by 1 hour"
            level: INFO
  - platform: template
    name: "Minute Increment"
    id: minute_increment
    web_server:
      sorting_group_id: sorting_time
    on_press:
      then:
        - rtttl.play: 'short:d=4,o=5,b=100:16e6'
        - switch.turn_off: sntp_switch
        - if:
            condition:
              time.has_time:
                id: rtc_time
            then:
              - datetime.datetime.set:
                    id: custom_time
                    datetime: !lambda 'return id(rtc_time).now();'
        - lambda: |-
            setenv("TZ", id(time_zone)->state.c_str(), 1);
            tzset();
            struct tm time_info;
            auto *time = id(custom_time);
            time_info.tm_year = time->year - 1900;
            time_info.tm_mon = time->month - 1;
            time_info.tm_mday = time->day;
            time_info.tm_hour = time->hour;
            time_info.tm_min = time->minute + 1;
            time_info.tm_sec = time->second;
            time_info.tm_isdst = -1;
            std::time_t t = mktime(&time_info);
            struct timeval tv = {t, 0};
            settimeofday(&tv, NULL);
            ESP_LOGD("main", "System time set to: %s", ctime(&t));
        - pcf8563.write_time:
            id: rtc_time
        - datetime.datetime.set:
              id: custom_time
              datetime: !lambda |-
                  auto time = id(rtc_time).now();
                  return time;
        - logger.log: 
            format: "RTC incremented by 1 minute"
            level: INFO

  - platform: template
    name: "Start Timer"
    id: start_timer_button
    web_server:
      sorting_group_id: sorting_timer
    on_press:
      then:
        - lambda: |-
            int h = (int)id(timer_hours).state;
            int m = (int)id(timer_minutes).state;
            int s = (int)id(timer_seconds).state;
            id(RingClock)->start_timer(h, m, s);
        - light.turn_on:
            id: ring_light
            effect: Timer

  - platform: template
    name: "Stop Timer & Stopwatch"
    id: stop_timer_button
    web_server:
      sorting_group_id: sorting_timer
    on_press:
      then:
        - lambda: 'id(RingClock)->stop_timer();'
        - light.turn_on:
            id: ring_light
            effect: Clock

  - platform: template
    name: "Start Stopwatch"
    id: start_stopwatch_button
    web_server:
      sorting_group_id: sorting_timer
    on_press:
      then:
        - lambda: 'id(RingClock)->start_stopwatch();'
        - light.turn_on:
            id: ring_light
            effect: Stopwatch

  - platform: template
    name: "Pause Stopwatch"
    id: pause_stopwatch_button
    web_server:
      sorting_group_id: sorting_timer
    on_press:
      then:
        - lambda: 'id(RingClock)->stop_stopwatch();'

  - platform: template
    name: "Reset Stopwatch"
    id: reset_stopwatch_button
    web_server:
      sorting_group_id: sorting_timer
    on_press:
      then:
        - lambda: 'id(RingClock)->reset_stopwatch();'

  - platform: template
    name: "Set Custom Time"
    id: custom_sync
    web_server:
      sorting_group_id: sorting_time
    on_press:
      then:
        - if:
            condition:
              - switch.is_off: sntp_switch
            then:
              - lambda: |-
                  setenv("TZ", id(time_zone)->state.c_str(), 1);
                  tzset();
                  struct tm time_info;
                  auto *time = id(custom_time);
                  time_info.tm_year = time->year - 1900;
                  time_info.tm_mon = time->month - 1;
                  time_info.tm_mday = time->day;
                  time_info.tm_hour = time->hour;
                  time_info.tm_min = time->minute;
                  time_info.tm_sec = time->second;
                  time_info.tm_isdst = -1;
                  std::time_t t = mktime(&time_info);
                  struct timeval tv = {t, 0};
                  settimeofday(&tv, NULL);
                  ESP_LOGD("main", "System time set to: %s", ctime(&t));
              - pcf8563.write_time:
                  id: rtc_time
              - logger.log: 
                  format: "RTC updated with custom time"
                  level: INFO
            else:
              - logger.log:
                  format: "Custom time NOT set - SNTP sync active"
                  level: WARN

switch:
  - platform: template
    name: "Enable SNTP Sync"
    id: sntp_switch
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_time
  - platform: template
    name: "Presense Detection Dimming"
    id: presense_detection
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF
    web_server:
      sorting_group_id: sorting_clock
  - platform: template
    name: "Enable Seconds"
    id: enable_seconds
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_clock
  - platform: template
    name: "Enable Markers"
    id: enable_markers
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_clock
  - platform: template
    name: "Timer or Stopwatch Sounds"
    id: timer_sounds
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_timer
  - platform: template
    name: "Alarm Enabled"
    id: alarm_enabled
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF
    web_server:
      sorting_group_id: sorting_alarm
  - platform: template
    name: "Alarm Sounds"
    id: alarm_sound
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_alarm
  - platform: template
    name: "Alarm Once"
    id: alarm_once
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF
    web_server:
      sorting_group_id: sorting_alarm


datetime:
  - platform: template
    name: "Custom Time"
    id: custom_time
    type: datetime
    initial_value: "2025-01-01 12:00:00"
    optimistic: True
    web_server:
      sorting_group_id: sorting_time
  - platform: template
    name: "Alarm Time"
    id: alarm_time
    type: time
    initial_value: "07:00:00"
    optimistic: True
    restore_value: True
    web_server:
      sorting_group_id: sorting_alarm



time:
  - platform: pcf8563
    address: 0x51
    update_interval: never
    id: rtc_time
    on_time:
      - seconds: 0
        minutes: /1
        then:
          - datetime.datetime.set:
              id: custom_time
              datetime: !lambda |-
                  auto time = id(rtc_time).now();
                  return time;
      - seconds: 0
        minutes: /1
        then:
          - lambda: |-
              auto now = id(rtc_time).now();
              auto alarm = id(alarm_time);
              if (id(alarm_enabled).state && now.hour == alarm->hour && now.minute == alarm->minute) {
                id(RingClock)->start_alarm();
                if (id(alarm_once).state) {
                  id(alarm_enabled).turn_off();
                }
              }

  - platform: sntp
    id: sntp_time
    on_time_sync:
      then:
        - if:
            condition:
              - switch.is_on: sntp_switch
            then:
              - pcf8563.write_time:
                  id: rtc_time
              - logger.log: 
                  format: "SNTP Time Synchronised and RTC updated"
                  level: INFO

light:
  # Main LED Rings
  - id: ring_light
    name: "Ring Light"
    platform: esp32_rmt_led_strip
    rgb_order: GRB
    chipset: ws2812
    pin: GPIO10
    num_leds: 108
    gamma_correct: 2.2
    # WARNING Increasing the values above 75% will exceed the devices electrical current limits and may cause overheating and physical damage
    color_correct: [75%, 75%, 75%]
    web_server:
      sorting_group_id: sorting_clock
    on_state:
      - lambda: |-
          if (id(ring_light).remote_values.is_on()) {
            std::string effect = id(ring_light).get_effect_name();
            if (effect == "Clock" || effect == "Clock (Fade)" || effect == "Clock (Rainbow)") {
              id(last_clock_effect) = effect;
            }
          }
    effects:
      - addressable_lambda:
          name: Clock
          update_interval: 50ms
          lambda: |-
            id(RingClock)->set_state(ring_clock::state::time);
            id(RingClock)->addressable_lights_lambdacall(it);
      - addressable_lambda:
          name: "Clock (Fade)"
          update_interval: 33ms
          lambda: |-
            id(RingClock)->set_state(ring_clock::state::time_fade);
            id(RingClock)->addressable_lights_lambdacall(it);
      - addressable_lambda:
          name: "Clock (Rainbow)"
          update_interval: 33ms
          lambda: |-
            id(RingClock)->set_state(ring_clock::state::time_rainbow);
            id(RingClock)->addressable_lights_lambdacall(it);
      - addressable_lambda:
          name: "Timer"
          update_interval: 100ms
          lambda: |-
            id(RingClock)->set_state(ring_clock::state::timer);
            id(RingClock)->addressable_lights_lambdacall(it);
      - addressable_lambda:
          name: "Stopwatch"
          update_interval: 100ms
          lambda: |-
            id(RingClock)->set_state(ring_clock::state::stopwatch);
            id(RingClock)->addressable_lights_lambdacall(it);
  # Customise Hour Hand
  - platform: rgb
    id: hour_hand_color
    name: "Hour Hand"
    restore_mode: RESTORE_DEFAULT_OFF
    default_transition_length: 0s
    red: output_hour_red
    green: output_hour_green
    blue: output_hour_blue
    web_server:
      sorting_group_id: sorting_clock_led
  # Customise Minute Hand
  - platform: rgb
    id: minute_hand_color
    name: "Minute Hand"
    restore_mode: RESTORE_DEFAULT_OFF
    default_transition_length: 0s
    red: output_minute_red
    green: output_minute_green
    blue: output_minute_blue
    web_server:
      sorting_group_id: sorting_clock_led
  # Customise Second Hand
  - platform: rgb
    id: second_hand_color
    name: "Second Hand"
    restore_mode: RESTORE_DEFAULT_OFF
    default_transition_length: 0s
    red: output_second_red
    green: output_second_green
    blue: output_second_blue
    web_server:
      sorting_group_id: sorting_clock_led
  # Customise Markers
  - platform: rgb
    id: marker_color
    name: "Markers"
    restore_mode: RESTORE_DEFAULT_OFF
    default_transition_length: 1s
    red: output_marker_red
    green: output_marker_green
    blue: output_marker_blue
    web_server:
      sorting_group_id: sorting_clock_led
    effects:
      - random:
  # Remaining Inner Ring LEDs
  - platform: rgb
    id: notification_color
    name: "Notification"
    restore_mode: RESTORE_DEFAULT_OFF
    default_transition_length: 1s
    red: output_notification_red
    green: output_notification_green
    blue: output_notification_blue
    web_server:
      sorting_group_id: sorting_clock_led
    effects:
      - random:
      - pulse:
          name: "Fast Pulse"
          transition_length: 0.5s
          update_interval: 0.5s
          min_brightness: 50%
          max_brightness: 100%
      - pulse:
          name: "Slow Pulse"
          transition_length: 500ms
          update_interval: 2s
      - automation:
          name: "Sensors: Dual Bars"
          sequence: []
      - automation:
          name: "Sensors: Temperature Bar"
          sequence: []
      - automation:
          name: "Sensors: Humidity Bar"
          sequence: []
      - automation:
          name: "Sensors: Dual Ticks"
          sequence: []
      - automation:
          name: "Sensors: Temperature Tick"
          sequence: []
      - automation:
          name: "Sensors: Humidity Tick"
          sequence: []
      - automation:
          name: "Sensors: Dual Glow"
          sequence: []
      - automation:
          name: "Sensors: Temperature Glow"
          sequence: []
      - automation:
          name: "Sensors: Humidity Glow"
          sequence: []

output:
  # Dummy LED Outputs
  - platform: template
    id: output_hour_red
    type: float
    write_action: {}
  - platform: template
    id: output_hour_green
    type: float
    write_action: {}
  - platform: template
    id: output_hour_blue
    type: float
    write_action: {}
  - platform: template
    id: output_minute_red
    type: float
    write_action: {}
  - platform: template
    id: output_minute_green
    type: float
    write_action: {}
  - platform: template
    id: output_minute_blue
    type: float
    write_action: {}
  - platform: template
    id: output_second_red
    type: float
    write_action: {}
  - platform: template
    id: output_second_green
    type: float
    write_action: {}
  - platform: template
    id: output_second_blue
    type: float
    write_action: {}
  - platform: template
    id: output_marker_red
    type: float
    write_action: {}
  - platform: template
    id: output_marker_green
    type: float
    write_action: {}
  - platform: template
    id: output_marker_blue
    type: float
    write_action: {}
  - platform: template
    id: output_notification_red
    type: float
    write_action: {}
  - platform: template
    id: output_notification_green
    type: float
    write_action: {}
  - platform: template
    id: output_notification_blue
    type: float
    write_action: {}
  #Buzzer Output  
  - platform: ledc
    pin: GPIO7
    id: buzzer

rtttl:
  output: buzzer
  id: buzzer_rtttl
  gain: 90%

