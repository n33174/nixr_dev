globals:
  # Track long press state for continuous increment
  - id: minute_button_long_press
    type: bool
    initial_value: 'false'
  - id: hour_button_long_press
    type: bool
    initial_value: 'false'
  - id: timer_h
    type: int
    initial_value: '0'
  - id: timer_m
    type: int
    initial_value: '0'
  - id: timer_s
    type: int
    initial_value: '0'

switch:
  # Toggle for brightness sensor reading
  - platform: template
    name: "Enable Brightness Sensor"
    id: enable_brightness
    icon: mdi:brightness-auto
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    web_server:
      sorting_group_id: sorting_sensors
      sorting_weight: 8
  # Toggle presense based dimming
  - platform: template
    name: "Presense Detection Dimming"
    id: presense_detection
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_clock
      sorting_weight: 4
  # Toggle to mute timer/stopwatch sounds
  - platform: template
    name: "Timer & Stopwatch Sounds"
    id: timer_sounds
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_timer
      sorting_weight: 7

binary_sensor:
  # Mode Button (Physical)
  # - Single Click: Cycle Clock Effects
  # - Double Click: Cycle Sensor Effects
  # - Long Press: Toggle Presence Detection
  - platform: gpio
    id: mode_button
    pin:
      number: GPIO2
      inverted: True
      mode: INPUT_PULLUP
    name: "Mode Button"
    internal: true
    filters:
      - delayed_on_off: 50ms
    on_multi_click:
      # Single Click: Next Clock Effect
      - timing:
          - ON for 50ms to 500ms
          - OFF for at least 600ms
        then:
          - lambda: |-
              auto call = id(ring_light).turn_on();
              std::string current = id(ring_light).get_effect_name();
              if (current == "Clock") call.set_effect("Clock (Fade)");
              else if (current == "Clock (Fade)") call.set_effect("Clock (Rainbow)");
              else if (current == "Clock (Rainbow)") call.set_effect("Clock (RGB)");
              else if (current == "Clock (RGB)") call.set_effect("Clock (Mono)");
              else call.set_effect("Clock");
              call.perform();
          - rtttl.play: 'click:d=16,o=6,b=120:c'
      # Double Click: Cycle Sensory Effects on Notification Layer
      - timing:
          - ON for 50ms to 500ms
          - OFF for 50ms to 350ms
          - ON for 50ms to 500ms
          - OFF for at least 50ms
        then:
          - lambda: |-
              bool is_on = id(notification_color).remote_values.is_on();
              std::string effect = id(notification_color).get_effect_name();
              
              if (!is_on || effect == "None") {
                auto call = id(notification_color).turn_on();
                call.set_effect("Sensors: Dual Bars");
                call.perform();
              } else if (effect == "Sensors: Dual Bars") {
                auto call = id(notification_color).turn_on();
                call.set_effect("Sensors: Temperature Bar");
                call.perform();
              } else if (effect == "Sensors: Temperature Bar") {
                auto call = id(notification_color).turn_on();
                call.set_effect("Sensors: Humidity Bar");
                call.perform();
              } else if (effect == "Sensors: Humidity Bar") {
                auto call = id(notification_color).turn_on();
                call.set_effect("Sensors: Dual Ticks");
                call.perform();
              } else if (effect == "Sensors: Dual Ticks") {
                auto call = id(notification_color).turn_on();
                call.set_effect("Sensors: Temperature Tick");
                call.perform();
              } else if (effect == "Sensors: Temperature Tick") {
                auto call = id(notification_color).turn_on();
                call.set_effect("Sensors: Humidity Tick");
                call.perform();
              } else if (effect == "Sensors: Humidity Tick") {
                auto call = id(notification_color).turn_on();
                call.set_effect("Sensors: Dual Glow");
                call.perform();
              } else if (effect == "Sensors: Dual Glow") {
                auto call = id(notification_color).turn_on();
                call.set_effect("Sensors: Temperature Glow");
                call.perform();
              } else if (effect == "Sensors: Temperature Glow") {
                auto call = id(notification_color).turn_on();
                call.set_effect("Sensors: Humidity Glow");
                call.perform();
              } else {
                // Includes "Sensors: Humidity Glow" and any other stray states
                id(notification_color).turn_off().perform();
              }
          - rtttl.play: 'double:d=16,o=6,b=120:c,g'
      # Long Press: Toggle Presence detection
      - timing:
          - ON for at least 1s
        then:
          - switch.toggle: presense_detection
          - if:
              condition:
                - switch.is_on: presense_detection
              then:
                - rtttl.play: 'on:d=16,o=6,b=120:c,e,g'
              else:
                - rtttl.play: 'off:d=16,o=6,b=120:g,e,c'

  # Hour Button (Physical)
  # - Single Click: Increment Hour (if minute button not held)
  # - Long Press (1s): Start continuous increment (if minute button not held)
  - platform: gpio
    id: hour_button
    pin:
      number: GPIO8
      inverted: True
      mode: INPUT_PULLUP
    name: "Hour Button"
    internal: true
    filters:
      - delayed_on_off: 50ms
    on_multi_click:
      # Single click: Increment Hour
      - timing:
          - ON for 50ms to 800ms
          - OFF for at least 100ms
        then:
          - if:
              condition:
                - lambda: 'return !id(minute_button).state;'
              then:
                - rtttl.play: 'short:d=4,o=5,b=100:16e6'
                - switch.turn_off: sntp_switch
                - lambda: |-
                    setenv("TZ", id(time_zone)->state.c_str(), 1);
                    tzset();
                    time_t t_now = ::time(NULL);
                    struct tm *ti = ::localtime(&t_now);
                    ti->tm_hour = (ti->tm_hour + 1) % 24;
                    ti->tm_isdst = -1;
                    time_t t_new = mktime(ti);
                    struct timeval tv = {t_new, 0};
                    settimeofday(&tv, NULL);
                - pcf8563.write_time:
                    id: rtc_time
                - logger.log: 
                    format: "RTC incremented by 1 hour"
                    level: INFO
      # Long press (Hold 1s): Start continuous increment
      - timing:
          - ON for at least 1s
        then:
          - if:
              condition:
                - lambda: 'return !id(minute_button).state;'
              then:
                - lambda: |-
                    id(hour_button_long_press) = true;
      # Release handler for continuous increment
      - timing:
          - OFF for at least 50ms
        then:
          lambda: |-
            id(hour_button_long_press) = false;
            
  # Minute Button (Physical)
  # - Single Click: Increment Minute (if hour button not held)
  # - Long Press (1s): Start continuous increment (if hour button not held)
  - platform: gpio
    id: minute_button
    pin:
      number: GPIO9
      inverted: True
      mode: INPUT_PULLUP
    name: "Minute Button"
    internal: true
    filters:
      - delayed_on_off: 50ms
    on_multi_click:
      # Single click: Increment Minute
      - timing:
          - ON for 50ms to 800ms
          - OFF for at least 100ms
        then:
          - if:
              condition:
                - lambda: 'return !id(hour_button).state;'
              then:
                - rtttl.play: 'short:d=4,o=5,b=100:16e6'
                - switch.turn_off: sntp_switch
                - lambda: |-
                    setenv("TZ", id(time_zone)->state.c_str(), 1);
                    tzset();
                    time_t t_now = ::time(NULL);
                    struct tm *ti = ::localtime(&t_now);
                    ti->tm_min = (ti->tm_min + 1) % 60;
                    ti->tm_isdst = -1;
                    time_t t_new = mktime(ti);
                    struct timeval tv = {t_new, 0};
                    settimeofday(&tv, NULL);
                - pcf8563.write_time:
                    id: rtc_time
                - logger.log: 
                    format: "RTC incremented by 1 minute"
                    level: INFO
      # Long press (1s): Start continuous increment
      - timing:
          - ON for at least 1s
        then:
          - if:
              condition:
                - lambda: 'return !id(hour_button).state;'
              then:
                - lambda: |-
                    id(minute_button_long_press) = true;
      # Release handler for continuous increment
      - timing:
          - OFF for at least 50ms
        then:
          lambda: |-
            id(minute_button_long_press) = false;

  # Maintenance Mode (Chord: Hour + Minute)
  # - Hold Both for 3s: Re-enable SNTP & Reboot
  # - Hold Both for 10s: Factory Reset
  - platform: template
    id: maintenance_mode
    name: "Maintenance Mode"
    internal: true
    lambda: |-
      return id(hour_button).state && id(minute_button).state;
    on_multi_click:
      # Hold both 2-10s: SNTP On + Reboot
      - timing:
          - ON for 2s to 10s
        then:
          - switch.turn_on: sntp_switch
          - rtttl.play: 'reboot:d=16,o=6,b=120:c7,g6,e6,c6'
          - delay: 500ms
          - button.press: restart_esp
      # Hold both 10s+: Factory Reset
      - timing:
          - ON for at least 10s
        then:
          - rtttl.play: 'reset:d=1,o=6,b=120:c'
          - delay: 500ms
          - button.press: delete_all_config

interval:
  # Polling loop for handling button "hold to increment" logic
  - interval: 250ms
    then:
      lambda: |-
        if (id(minute_button_long_press)) {
          // Minute increment logic
          setenv("TZ", id(time_zone)->state.c_str(), 1);
          tzset();
          time_t t_now = ::time(NULL);
          struct tm *ti = ::localtime(&t_now);
          ti->tm_min = (ti->tm_min + 1) % 60;
          ti->tm_isdst = -1;
          time_t t_new = mktime(ti);
          struct timeval tv = {t_new, 0};
          settimeofday(&tv, NULL);
          id(rtc_time)->write_time();
        }
        if (id(hour_button_long_press)) {
          // Hour increment logic
          setenv("TZ", id(time_zone)->state.c_str(), 1);
          tzset();
          time_t t_now = ::time(NULL);
          struct tm *ti = ::localtime(&t_now);
          ti->tm_hour = (ti->tm_hour + 1) % 24;
          ti->tm_isdst = -1;
          time_t t_new = mktime(ti);
          struct timeval tv = {t_new, 0};
          settimeofday(&tv, NULL);
          id(rtc_time)->write_time();
        }

button:
  # System Actions
  - platform: restart
    name: Restart
    id: restart_esp
    web_server:
      sorting_group_id: sorting_system
  - platform: factory_reset
    name: Reset with Default Settings
    id: delete_all_config
    disabled_by_default: True
    web_server:
      sorting_group_id: sorting_system

  # Consolidated Update Management
  - platform: template
    name: "Update Firmware"
    id: update_firmware_button
    web_server:
      sorting_group_id: sorting_system
      sorting_weight: 2
    on_press:
      then:
        - logger.log: "Initiating firmware update process..."
        - update.check: firmware_update
        - delay: 3s # Allow time for manifest fetch and parsing
        - if:
            condition:
              update.is_available: firmware_update
            then:
              - logger.log: "New version found! Starting Over-The-Air (OTA) update..."
              - update.perform: firmware_update
            else:
              - logger.log: "No update available. Your clock is currently up to date."

  # Buzzer
  - platform: template
    name: Buzzer
    web_server:
      sorting_group_id: sorting_alarm
      sorting_weight: 5
    on_press: 
      then:
        - rtttl.play: notification:d=16,o=6,b=160:c,e,g,c7


  # Timer Controls
  - platform: template
    name: "Start Timer"
    id: start_timer_button
    web_server:
      sorting_group_id: sorting_timer
      sorting_weight: 5
    on_press:
      then:
        - lambda: |-
            id(RingClock)->start_timer(id(timer_h), id(timer_m), id(timer_s));
        - light.turn_on:
            id: ring_light
            effect: Timer

  - platform: template
    name: "Stop Timer"
    id: stop_timer_button
    web_server:
      sorting_group_id: sorting_timer
      sorting_weight: 6
    on_press:
      then:
        - lambda: 'id(RingClock)->stop_timer();'
        - light.turn_on:
            id: ring_light
            effect: Clock

  # Stopwatch Controls
  - platform: template
    name: "Start Stopwatch"
    id: start_stopwatch_button
    web_server:
      sorting_group_id: sorting_timer
      sorting_weight: 1
    on_press:
      then:
        - lambda: 'id(RingClock)->start_stopwatch();'
        - light.turn_on:
            id: ring_light
            effect: Stopwatch

  - platform: template
    name: "Pause Stopwatch"
    id: pause_stopwatch_button
    web_server:
      sorting_group_id: sorting_timer
      sorting_weight: 2
    on_press:
      then:
        - lambda: 'id(RingClock)->pause_stopwatch();'

  - platform: template
    name: "Stop Stopwatch"
    id: stop_stopwatch_button
    web_server:
      sorting_group_id: sorting_timer
      sorting_weight: 3
    on_press:
      then:
        - lambda: 'id(RingClock)->stop_stopwatch();'
        - light.turn_on:
            id: ring_light
            effect: Clock

text:
  - platform: template
    name: "Timer Duration"
    id: timer_duration
    mode: text
    optimistic: true
    initial_value: "00:00:00"
    web_server:
      sorting_group_id: sorting_timer
      sorting_weight: 4
    on_value:
      then:
        - lambda: |-
            std::string s = x;
            if (s.empty()) return;
            
            // Clean input: remove everything except digits and colons
            std::string clean;
            for (char c : s) {
                if (isdigit(c) || c == ':') clean += c;
            }
            
            std::vector<int> parts;
            std::string current;
            for (char c : clean) {
                if (c == ':') {
                    if (!current.empty()) parts.push_back(std::stoi(current));
                    current = "";
                } else {
                    current += c;
                }
            }
            if (!current.empty()) parts.push_back(std::stoi(current));
            
            int h = 0, m = 0, sec = 0;
            if (parts.size() == 1) {
                sec = parts[0];
            } else if (parts.size() == 2) {
                m = parts[0];
                sec = parts[1];
            } else if (parts.size() >= 3) {
                h = parts[0];
                m = parts[1];
                sec = parts[2];
            }
            
            // Normalize (e.g. 90s -> 1m30s)
            int total_seconds = h * 3600 + m * 60 + sec;
            if (total_seconds < 0) total_seconds = 0;
            if (total_seconds > 46799) total_seconds = 46799; // Cap at 12:59:59
            
            id(timer_h) = total_seconds / 3600;
            id(timer_m) = (total_seconds % 3600) / 60;
            id(timer_s) = total_seconds % 60;
            
            char buf[10];
            sprintf(buf, "%02d:%02d:%02d", id(timer_h), id(timer_m), id(timer_s));
            std::string formatted = buf;
            
            if (formatted != s) {
               auto call = id(timer_duration).make_call();
               call.set_value(formatted);
               call.perform();
            }

number:
  # Calibration controls for environmental sensors
  - platform: template
    name: "Temperature Offset"
    id: temp_offset
    unit_of_measurement: "Â°C"
    step: 0.1
    icon: mdi:thermometer-lines
    initial_value: ${temp_offset_default}
    optimistic: true
    restore_value: true
    min_value: -20.0
    max_value: 20.0
    disabled_by_default: True
    web_server:
      sorting_group_id: sorting_sensors
      sorting_weight: 9
    on_value:
      then:
        - component.update: aht_sensor

  - platform: template
    name: "Humidity Offset"
    id: humidity_offset
    unit_of_measurement: "%"
    step: 1
    icon: mdi:water-percent-alert
    initial_value: ${humidity_offset_default}
    optimistic: true
    restore_value: true
    min_value: -20
    max_value: 20
    disabled_by_default: True
    web_server:
      sorting_group_id: sorting_sensors
      sorting_weight: 10
    on_value:
      then:
        - component.update: aht_sensor
