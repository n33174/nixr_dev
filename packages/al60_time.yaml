globals:
  - id: timezone_configured
    type: bool
    restore_value: true
    initial_value: 'false'
  - id: detected_iana
    type: std::string
  - id: detected_offset
    type: std::string

esphome:
  on_boot:
    # Read time from the hardware RTC as early as possible on boot
    - priority: 300
      then:
        - pcf8563.read_time:
              id: rtc_time
    # Set the timezone after enough time has passed for restoration from memory
    - priority: 200
      then:
        - lambda: |-
            setenv("TZ", id(time_zone)->state.c_str(), 1);
            tzset();
            ESP_LOGD("main", "Boot - Applied restored timezone: %s", id(time_zone)->state.c_str());
    # Auto-detect timezone on first connection if not already configured
    - priority: 100
      then:
        - wait_until:
            condition:
              wifi.connected:
        - update.check: firmware_update
        - if:
            condition:
              lambda: |-
                return !id(timezone_configured); 
            then:
              - button.press: detect_timezone
              - globals.set:
                  id: timezone_configured
                  value: 'true'

time:
  # Hardware Real Time Clock (PCF8563)
  # Acts as the primary time source when offline
  - platform: pcf8563
    address: 0x51
    update_interval: never # Only update manually or on SNTP sync
    id: rtc_time
    timezone: UTC
    on_time:
      # Alarm logic: Check every minute if alarm should fire
      - seconds: 0
        minutes: /1
        then:
          - lambda: |-
              time_t t = ::time(NULL);
              auto now = esphome::ESPTime::from_c_tm(::localtime(&t), 0);
              auto alarm = id(alarm_time);
              // Check if alarm is enabled and matches current Hour/Minute
              if (id(alarm_enabled).state && now.hour == alarm->hour && now.minute == alarm->minute) {
                id(RingClock)->start_alarm();
                // Disable alarm after firing if 'Once' mode is active
                if (id(alarm_once).state) {
                  id(alarm_enabled).turn_off();
                }
              }

  # Internet Time Sync (SNTP)
  - platform: sntp
    id: sntp_time
    timezone: UTC
    on_time_sync:
      then:
        # Update the hardware RTC if SNTP sync switch is enabled
        - if:
            condition:
              - switch.is_on: sntp_switch
            then:
              - pcf8563.write_time:
                  id: rtc_time
              - logger.log: 
                  format: "SNTP Time Synchronised and RTC updated"
                  level: INFO

datetime:
  # Template to allow users to manually set time via Web UI
  - platform: template
    name: "Custom Time"
    id: custom_time
    type: datetime
    initial_value: "2025-01-01 12:00:00"
    optimistic: True
    web_server:
      sorting_group_id: sorting_time
      sorting_weight: 3
    on_value:
      then:
        - switch.turn_off: sntp_switch
        - lambda: |-
            setenv("TZ", id(time_zone)->state.c_str(), 1);
            tzset();
            struct tm time_info;
            // Use 'x' which is the ESPTime provided by on_value
            time_info.tm_year = x.year - 1900;
            time_info.tm_mon = x.month - 1;
            time_info.tm_mday = x.day_of_month;
            time_info.tm_hour = x.hour;
            time_info.tm_min = x.minute;
            time_info.tm_sec = x.second;
            time_info.tm_isdst = -1;
            std::time_t t = mktime(&time_info);
            struct timeval tv = {t, 0};
            settimeofday(&tv, NULL);
            ESP_LOGD("main", "System time updated from Web UI: %s", ctime(&t));
        - pcf8563.write_time:
            id: rtc_time
        - logger.log:
            format: "Manual time applied. SNTP sync disabled."
            level: INFO
  
  # Alarm time setting
  - platform: template
    name: "Alarm Time"
    id: alarm_time
    type: time
    initial_value: "07:00:00"
    optimistic: True
    restore_value: True # Remember alarm time across reboots
    web_server:
      sorting_group_id: sorting_alarm
      sorting_weight: 4

switch:
  # Master switch for internet time sync
  - platform: template
    name: "Enable SNTP Sync"
    id: sntp_switch
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_time
      sorting_weight: 2
    on_turn_on:
      then:
        - logger.log:
            format: "SNTP Sync enabled. It is recommended to restart the clock to trigger time sync."
            level: INFO

  # Alarm Controls
  - platform: template
    name: "Alarm Enabled"
    id: alarm_enabled
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF
    web_server:
      sorting_group_id: sorting_alarm
      sorting_weight: 1
  
  # Run alarm once then disable
  - platform: template
    name: "Alarm Once"
    id: alarm_once
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF
    web_server:
      sorting_group_id: sorting_alarm
      sorting_weight: 2
  
  # Toggle alarm sounds
  - platform: template
    name: "Alarm Sounds"
    id: alarm_sound
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_alarm
      sorting_weight: 3
    
text:
  # Text field to set Time Zone
  # Controls how the offset is calculated
  - platform: template
    name: "Time Zone"
    id: time_zone
    mode: text
    optimistic: true
    restore_value: true
    initial_value: ${time_zone}
    web_server:
      sorting_group_id: sorting_time
      sorting_weight: 1
    on_value:
      then:
        - lambda: |-
            setenv("TZ", x.c_str(), 1);
            tzset();
            ESP_LOGI("main", "Timezone updated to: %s", x.c_str());
        - lambda: |-
            id(timezone_configured) = true;
button:
  # Detect Timezone via IP Geolocation (WorldTimeAPI)
  - platform: template
    name: "Auto-Detect Time Zone"
    id: detect_timezone
    web_server:
      sorting_group_id: sorting_time
      sorting_weight: 5
    on_press:
      then:
        - logger.log: "Stage 1: Detecting IANA Timezone..."
        - http_request.get:
            url: "http://ipwho.is/"
            request_headers:
              User-Agent: "ESPHome/AL60"
            capture_response: true
            on_response:
              then:
                - lambda: |-
                    if (body.empty()) {
                      ESP_LOGE("main", "Timezone Stage 1 failed. Check internet.");
                      return;
                    }
                    json::parse_json(body, [](JsonObject root) -> bool {
                      JsonObject tz = root["timezone"];
                        if (tz["id"].is<const char*>() && tz["utc"].is<const char*>()) {
                          id(detected_iana) = tz["id"].as<std::string>();
                          id(detected_offset) = tz["utc"].as<std::string>();
                          id(fetch_posix_rule).press(); // Trigger Stage 2
                          return true;
                        }
                      return false;
                    });

  # Stage 2: Lookup POSIX Rule from our static database
  - platform: template
    name: "Fetch POSIX Rule"
    id: fetch_posix_rule
    internal: true # Hidden from UI
    on_press:
      then:
        - logger.log: "Stage 2: Looking up POSIX rule for city..."
        - http_request.get:
            url: !lambda |-
               std::string iana = id(detected_iana);
               size_t pos = iana.find('/');
               std::string continent = (pos != std::string::npos) ? iana.substr(0, pos) : "Etc";
               return "https://n33174.github.io/nixr_dev/static/" + continent + ".json";
            request_headers:
              User-Agent: "ESPHome/AL60"
            capture_response: true
            on_response:
              then:
                - lambda: |-
                    bool found = false;
                    std::string iana = id(detected_iana);
                    if (!body.empty()) {
                      json::parse_json(body, [&found, iana](JsonObject root) -> bool {
                        size_t pos = iana.find('/');
                        std::string city = (pos != std::string::npos) ? iana.substr(pos + 1) : iana;
                        if (root[city].is<const char*>()) {
                          std::string posix = root[city].as<std::string>();
                          id(time_zone)->set(posix);
                          ESP_LOGI("main", "Success! Applied POSIX rule for %s: %s", iana.c_str(), posix.c_str());
                          found = true;
                          return true;
                        }
                        return false;
                      });
                    }

                    if (!found) {
                      ESP_LOGW("main", "City '%s' not in DB or DB unreachable. Fallback: ${time_zone}", iana.c_str());
                      id(time_zone)->set("${time_zone}");
                    }
