globals:
  - id: timezone_configured
    type: bool
    restore_value: true
    initial_value: 'false'
  - id: detected_iana
    type: std::string
  - id: detected_offset
    type: std::string

esphome:
  on_boot:
    # Read time from the hardware RTC as early as possible on boot
    - priority: 300
      then:
        - pcf8563.read_time:
              id: rtc_time
        - lambda: |-
            setenv("TZ", id(time_zone).state.c_str(), 1);
            tzset();
    # Auto-detect timezone on first connection if not already configured
    - priority: 100
      then:
        - wait_until:
            condition:
              wifi.connected:
        - if:
            condition:
              lambda: |-
                return !id(timezone_configured); 
            then:
              - button.press: detect_timezone
              - globals.set:
                  id: timezone_configured
                  value: 'true'

time:
  # Hardware Real Time Clock (PCF8563)
  # Acts as the primary time source when offline
  - platform: pcf8563
    address: 0x51
    update_interval: never # Only update manually or on SNTP sync
    id: rtc_time
    timezone: UTC
    on_time:
      # Sync logic: Update the 'Custom Time' template every minute
      - seconds: 0
        minutes: /1
        then:
          - datetime.datetime.set:
              id: custom_time
              datetime: !lambda |-
                  // Return local time based on system TZ
                  time_t t = ::time(NULL);
                  return esphome::ESPTime::from_c_tm(::localtime(&t), 0);
      # Alarm logic: Check every minute if alarm should fire
      - seconds: 0
        minutes: /1
        then:
          - lambda: |-
              time_t t = ::time(NULL);
              auto now = esphome::ESPTime::from_c_tm(::localtime(&t), 0);
              auto alarm = id(alarm_time);
              // Check if alarm is enabled and matches current Hour/Minute
              if (id(alarm_enabled).state && now.hour == alarm->hour && now.minute == alarm->minute) {
                id(RingClock)->start_alarm();
                // Disable alarm after firing if 'Once' mode is active
                if (id(alarm_once).state) {
                  id(alarm_enabled).turn_off();
                }
              }

  # Internet Time Sync (SNTP)
  - platform: sntp
    id: sntp_time
    timezone: UTC
    on_time_sync:
      then:
        # Update the hardware RTC if SNTP sync switch is enabled
        - if:
            condition:
              - switch.is_on: sntp_switch
            then:
              - pcf8563.write_time:
                  id: rtc_time
              - logger.log: 
                  format: "SNTP Time Synchronised and RTC updated"
                  level: INFO

datetime:
  # Template to allow users to manually set time via Web UI
  - platform: template
    name: "Custom Time"
    id: custom_time
    type: datetime
    initial_value: "2025-01-01 12:00:00"
    optimistic: True
    web_server:
      sorting_group_id: sorting_time
      sorting_weight: 3
  
  # Alarm time setting
  - platform: template
    name: "Alarm Time"
    id: alarm_time
    type: time
    initial_value: "07:00:00"
    optimistic: True
    restore_value: True # Remember alarm time across reboots
    web_server:
      sorting_group_id: sorting_alarm
      sorting_weight: 4

switch:
  # Master switch for internet time sync
  - platform: template
    name: "Enable SNTP Sync"
    id: sntp_switch
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_time
      sorting_weight: 2

  # Alarm Controls
  - platform: template
    name: "Alarm Enabled"
    id: alarm_enabled
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF
    web_server:
      sorting_group_id: sorting_alarm
      sorting_weight: 1
  
  # Run alarm once then disable
  - platform: template
    name: "Alarm Once"
    id: alarm_once
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF
    web_server:
      sorting_group_id: sorting_alarm
      sorting_weight: 2
  
  # Toggle alarm sounds
  - platform: template
    name: "Alarm Sounds"
    id: alarm_sound
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_alarm
      sorting_weight: 3
    
text:
  # Text field to set Time Zone (e.g. "Australia/Brisbane", "Europe/London")
  # Controls how the offset is calculated
  - platform: template
    name: "Time Zone"
    id: time_zone
    mode: text
    optimistic: true
    restore_value: true
    initial_value: ${time_zone}
    web_server:
      sorting_group_id: sorting_time
      sorting_weight: 1
    on_value:
      then:
        - lambda: |-
            setenv("TZ", x.c_str(), 1);
            tzset();
            ESP_LOGI("main", "Timezone updated to: %s", x.c_str());
        - pcf8563.write_time:
            id: rtc_time
        - globals.set:
            id: timezone_configured
            value: 'true'
button:
  # Detect Timezone via IP Geolocation (WorldTimeAPI)
  - platform: template
    name: "Auto-Detect Time Zone"
    id: detect_timezone
    web_server:
      sorting_group_id: sorting_time
      sorting_weight: 5
    on_press:
      then:
        - logger.log: "Stage 1: Detecting IANA Timezone..."
        - http_request.get:
            url: "http://ipwho.is/"
            headers:
              User-Agent: "ESPHome/AL60"
            capture_response: true
            on_response:
              then:
                - lambda: |-
                    if (body.empty()) {
                      ESP_LOGE("main", "Timezone Stage 1 failed. Check internet.");
                      return;
                    }
                    json::parse_json(body, [](JsonObject root) -> bool {
                      JsonObject tz = root["timezone"];
                      if (tz["id"].is<const char*>() && tz["utc"].is<const char*>()) {
                        id(detected_iana) = tz["id"].as<std::string>();
                        id(detected_offset) = tz["utc"].as<std::string>();
                        id(fetch_posix_rule).press(); // Trigger Stage 2
                        return true;
                      }
                      return false;
                    });

  # Stage 2: Lookup POSIX Rule from our static database
  - platform: template
    name: "Fetch POSIX Rule"
    id: fetch_posix_rule
    internal: true # Hidden from UI
    on_press:
      then:
        - logger.log: "Stage 2: Looking up POSIX rule for city..."
        - http_request.get:
            url: "https://n33174.github.io/nixr_dev/static/zones.json"
            headers:
              User-Agent: "ESPHome/AL60"
            capture_response: true
            on_response:
              then:
                - lambda: |-
                    if (body.empty()) {
                       ESP_LOGW("main", "Stage 2 DB unreachable. Falling back to offset.");
                       goto fallback;
                    }
                    
                    json::parse_json(body, [](JsonObject root) -> bool {
                      std::string city = id(detected_iana);
                      if (root[city].is<const char*>()) {
                        std::string posix = root[city].as<std::string>();
                        id(time_zone).publish_state(posix);
                        ESP_LOGI("main", "Success! Applied POSIX rule for %s: %s", city.c_str(), posix.c_str());
                        return true;
                      }
                      return false;
                    });
                    
                    // If we reach here and status isn't updated, fallback to offset
                    if (id(time_zone).state == "${time_zone}") {
                      fallback:
                      std::string offset = id(detected_offset);
                      char sign = offset[0];
                      std::string hh_mm = offset.substr(1, 5);
                      std::string inv_sign = (sign == '+') ? "-" : "+";
                      std::string fallback_posix = "UTC" + inv_sign + hh_mm;
                      id(time_zone).publish_state(fallback_posix);
                      ESP_LOGI("main", "City not in DB. Applied current offset fallback: %s", fallback_posix.c_str());
                    }
