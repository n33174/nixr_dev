esphome:
  on_boot:
    # Read time from the hardware RTC as early as possible on boot
    - priority: 300
      then:
        - pcf8563.read_time:
              id: rtc_time
        - lambda: |-
            setenv("TZ", id(time_zone).state.c_str(), 1);
            tzset();
    # Auto-detect timezone on first connection if not already configured
    - priority: 100
      then:
        - wait_until:
            condition:
              wifi.connected:
        - if:
            condition:
              lambda: |-
                return id(time_zone).state == "${time_zone}"; 
            then:
              - button.press: detect_timezone

time:
  # Hardware Real Time Clock (PCF8563)
  # Acts as the primary time source when offline
  - platform: pcf8563
    address: 0x51
    update_interval: never # Only update manually or on SNTP sync
    id: rtc_time
    timezone: UTC
    on_time:
      # Sync logic: Update the 'Custom Time' template every minute
      - seconds: 0
        minutes: /1
        then:
          - datetime.datetime.set:
              id: custom_time
              datetime: !lambda |-
                  // Return local time based on system TZ
                  time_t t = ::time(NULL);
                  return esphome::ESPTime::from_c_tm(::localtime(&t), 0);
      # Alarm logic: Check every minute if alarm should fire
      - seconds: 0
        minutes: /1
        then:
          - lambda: |-
              time_t t = ::time(NULL);
              auto now = esphome::ESPTime::from_c_tm(::localtime(&t), 0);
              auto alarm = id(alarm_time);
              // Check if alarm is enabled and matches current Hour/Minute
              if (id(alarm_enabled).state && now.hour == alarm->hour && now.minute == alarm->minute) {
                id(RingClock)->start_alarm();
                // Disable alarm after firing if 'Once' mode is active
                if (id(alarm_once).state) {
                  id(alarm_enabled).turn_off();
                }
              }

  # Internet Time Sync (SNTP)
  - platform: sntp
    id: sntp_time
    timezone: UTC
    on_time_sync:
      then:
        # Update the hardware RTC if SNTP sync switch is enabled
        - if:
            condition:
              - switch.is_on: sntp_switch
            then:
              - pcf8563.write_time:
                  id: rtc_time
              - logger.log: 
                  format: "SNTP Time Synchronised and RTC updated"
                  level: INFO

datetime:
  # Template to allow users to manually set time via Web UI
  - platform: template
    name: "Custom Time"
    id: custom_time
    type: datetime
    initial_value: "2025-01-01 12:00:00"
    optimistic: True
    web_server:
      sorting_group_id: sorting_time
      sorting_weight: 3
  
  # Alarm time setting
  - platform: template
    name: "Alarm Time"
    id: alarm_time
    type: time
    initial_value: "07:00:00"
    optimistic: True
    restore_value: True # Remember alarm time across reboots
    web_server:
      sorting_group_id: sorting_alarm
      sorting_weight: 4

switch:
  # Master switch for internet time sync
  - platform: template
    name: "Enable SNTP Sync"
    id: sntp_switch
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_time
      sorting_weight: 2

  # Alarm Controls
  - platform: template
    name: "Alarm Enabled"
    id: alarm_enabled
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF
    web_server:
      sorting_group_id: sorting_alarm
      sorting_weight: 1
  
  # Run alarm once then disable
  - platform: template
    name: "Alarm Once"
    id: alarm_once
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF
    web_server:
      sorting_group_id: sorting_alarm
      sorting_weight: 2
  
  # Toggle alarm sounds
  - platform: template
    name: "Alarm Sounds"
    id: alarm_sound
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_alarm
      sorting_weight: 3
    
text:
  # Text field to set Time Zone (e.g. "Australia/Brisbane", "Europe/London")
  # Controls how the offset is calculated
  - platform: template
    name: "Time Zone"
    id: time_zone
    mode: text
    optimistic: true
    initial_value: ${time_zone}
    web_server:
      sorting_group_id: sorting_time
      sorting_weight: 1
    on_value:
      then:
        - lambda: |-
            setenv("TZ", x.c_str(), 1);
            tzset();
            ESP_LOGI("main", "Timezone updated to: %s", x.c_str());
        - pcf8563.write_time:
            id: rtc_time
button:
  # Detect Timezone via IP Geolocation (WorldTimeAPI)
  - platform: template
    name: "Auto-Detect Time Zone"
    id: detect_timezone
    web_server:
      sorting_group_id: sorting_time
      sorting_weight: 5
    on_press:
      then:
        - http_request.get:
            url: "http://worldtimeapi.org/api/ip"
            capture_response: true
            on_response:
              then:
                - lambda: |-
                    json::parse_json(body, [](JsonObject root) -> bool {
                      if (root["utc_offset"].is<const char*>()) {
                        std::string offset = root["utc_offset"].as<std::string>();
                        // POSIX offsets have inverted signs (East is negative)
                        // Example: "+10:00" -> "UTC-10"
                        char sign = offset[0];
                        std::string hours = offset.substr(1, 2);
                        std::string inv_sign = (sign == '+') ? "-" : "+";
                        
                        id(time_zone).publish_state("UTC" + inv_sign + hours);
                        ESP_LOGI("main", "Auto-detected offset: UTC%c%s", inv_sign[0], hours.c_str());
                        return true;
                      }
                      return false;
                    });
