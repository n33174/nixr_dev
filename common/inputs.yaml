globals:
  # Track long press state for continuous increment
  - id: minute_button_long_press
    type: bool
    initial_value: 'false'
  - id: hour_button_long_press
    type: bool
    initial_value: 'false'

switch:
  # Toggle presense based dimming
  - platform: template
    name: "Presense Detection Dimming"
    id: presense_detection
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_clock
  # Toggle to mute timer/stopwatch sounds
  - platform: template
    name: "Timer or Stopwatch Sounds"
    id: timer_sounds
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_timer

binary_sensor:
  # Mode Button (Physical)
  # - Single Click: Cycle Clock Effects
  # - Double Click: Cycle Sensor Effects
  # - Long Press: Toggle Presence Detection
  - platform: gpio
    pin:
      number: GPIO2
      inverted: True
      mode: INPUT_PULLUP
    name: "Mode Button"
    internal: true
    filters:
      delayed_on_off: 50ms # Debouncing
    on_multi_click:
      # Single Click: Next Clock Effect
      - timing:
          - ON for 50ms to 500ms
          - OFF for at least 300ms
        then:
          - lambda: |-
              auto call = id(ring_light).turn_on();
              std::string current = id(ring_light).get_effect_name();
              if (current == "Clock") call.set_effect("Clock (Fade)");
              else if (current == "Clock (Fade)") call.set_effect("Clock (Rainbow)");
              else call.set_effect("Clock");
              call.perform();
          - rtttl.play: 'click:d=16,o=6,b=120:c'
      # Double Click: Next Sensor Effect
      - timing:
          - ON for 50ms to 500ms
          - OFF for 50ms to 300ms
          - ON for 50ms to 500ms
          - OFF for at least 50ms
        then:
          - lambda: |-
              auto call = id(ring_light).turn_on();
              std::string current = id(ring_light).get_effect_name();
              if (current == "Sensors (Bars)") call.set_effect("Sensors (Ticks)");
              else if (current == "Sensors (Ticks)") call.set_effect("Sensors (Dual Glow)");
              else if (current == "Sensors (Dual Glow)") call.set_effect("Sensors (Temp Glow)");
              else if (current == "Sensors (Temp Glow)") call.set_effect("Sensors (Humid Glow)");
              else call.set_effect("Sensors (Bars)");
              call.perform();
          - rtttl.play: 'double:d=16,o=6,b=120:c,g'
      # Long Press: Toggle Presence detection
      - timing:
          - ON for at least 1s
        then:
          - switch.toggle: presense_detection
          - if:
              condition:
                - switch.is_on: presense_detection
              then:
                - rtttl.play: 'on:d=16,o=6,b=120:c,e,g'
              else:
                - rtttl.play: 'off:d=16,o=6,b=120:g,e,c'

  # Hour Button (Physical)
  # - Single Click: Increment Hour
  # - Long Press (1s): Start continuous increment
  - platform: gpio
    id: hour_button_physical
    pin:
      number: GPIO8
      inverted: True
      mode: INPUT_PULLUP
    name: "Hour Button"
    internal: true
    filters:
      - delayed_on: 20ms
      - delayed_off: 20ms
    on_multi_click:
      # Single click: Increment Hour
      - timing:
          - ON for 40ms to 1s
          - OFF for at least 300ms
        then:
         - button.press: hour_increment
      # Long press (Hold 1s): Start continuous increment
      - timing:
          - ON for at least 1s
        then:
          lambda: |-
            id(hour_button_long_press) = true;
      # Release handler for continuous increment
      - timing:
          - OFF for at least 50ms
        then:
          lambda: |-
            id(hour_button_long_press) = false;
            
  # Minute Button (Physical)
  # - Single Click: Increment Minute
  # - Long Press (1s): Start continuous increment
  - platform: gpio
    id: minute_button_physical
    pin:
      number: GPIO9
      inverted: True
      mode: INPUT_PULLUP
    name: "Minute Button"
    internal: true
    filters:
      - delayed_on: 20ms
      - delayed_off: 20ms
    on_multi_click:
      # Single click
      - timing:
          - ON for 40ms to 1s
          - OFF for at least 300ms
        then:
         - button.press: minute_increment
      # Long press (1s): Start continuous increment
      - timing:
          - ON for at least 1s
        then:
          lambda: |-
            id(minute_button_long_press) = true;
      # Release handler for continuous increment
      - timing:
          - OFF for at least 50ms
        then:
          lambda: |-
            id(minute_button_long_press) = false;

  # Maintenance Mode (Chord: Hour + Minute)
  # - Hold Both for 3s: Reboot
  # - Hold Both for 10s: Factory Reset
  - platform: template
    id: maintenance_mode
    name: "Maintenance Mode"
    internal: true
    lambda: |-
      return id(hour_button_physical).state && id(minute_button_physical).state;
    on_multi_click:
      # Hold both 3-10s: Reboot
      - timing:
          - ON for 3s to 10s
        then:
          - rtttl.play: 'reboot:d=16,o=6,b=120:c7,g6,e6,c6'
          - delay: 500ms
          - button.press: restart_esp
      # Hold both 10s+: Factory Reset
      - timing:
          - ON for at least 10s
        then:
          - rtttl.play: 'reset:d=8,o=6,b=120:c,c,c,c'
          - delay: 500ms
          - button.press: delete_all_config

interval:
  # Polling loop for handling button "hold to increment" logic
  - interval: 250ms
    then:
      lambda: |-
        if (id(minute_button_long_press)) {
          id(minute_increment)->press();
        }
        if (id(hour_button_long_press)) {
          id(hour_increment)->press();
        }

button:
  # System Actions
  - platform: restart
    name: Restart
    id: restart_esp
    web_server:
      sorting_group_id: sorting_system
  - platform: factory_reset
    name: Reset with Default Settings
    id: delete_all_config
    disabled_by_default: True
    web_server:
      sorting_group_id: sorting_system

  # Buzzer
  - platform: template
    name: Buzzer
    web_server:
      sorting_group_id: sorting_other
    on_press: 
      then:
        - rtttl.play: notification:d=16,o=6,b=160:c,e,g,c7

  # Logic for Hour Increment
  # - Plays sound
  # - Disables SNTP (assumes manual override desired)
  # - Updates System Time, RTC, and WebUI
  - platform: template
    name: "Hour Increment"
    id: hour_increment
    disabled_by_default: True # Used by physical buttons - Hide from interface
    web_server:
      sorting_group_id: sorting_time
    on_press:
      then:
        - rtttl.play: 'short:d=4,o=5,b=100:16e6'
        - switch.turn_off: sntp_switch
        - if:
            condition:
              time.has_time:
                id: rtc_time
            then:
              - datetime.datetime.set:
                    id: custom_time
                    datetime: !lambda 'return id(rtc_time).now();'
        - lambda: |-
            setenv("TZ", id(time_zone)->state.c_str(), 1);
            tzset();
            struct tm time_info;
            auto *time = id(custom_time); // Get TemplateDateTime pointer
            time_info.tm_year = time->year - 1900;
            time_info.tm_mon = time->month - 1;
            time_info.tm_mday = time->day;
            time_info.tm_hour = time->hour + 1;
            time_info.tm_min = time->minute;
            time_info.tm_sec = time->second;
            time_info.tm_isdst = -1;
            std::time_t t = mktime(&time_info);
            struct timeval tv = {t, 0};
            settimeofday(&tv, NULL);
            ESP_LOGD("main", "System time set to: %s", ctime(&t));
        - pcf8563.write_time:
            id: rtc_time
        - datetime.datetime.set:
              id: custom_time
              datetime: !lambda |-
                  auto time = id(rtc_time).now();
                  return time;
        - logger.log: 
            format: "RTC incremented by 1 hour"
            level: INFO

  # Logic for Minute Increment
  # - Plays sound
  # - Disables SNTP (assumes manual override desired)
  # - Updates System Time, RTC, and WebUI
  - platform: template
    name: "Minute Increment"
    id: minute_increment
    disabled_by_default: True # Used by physical buttons - Hide from interface
    web_server:
      sorting_group_id: sorting_time
    on_press:
      then:
        - rtttl.play: 'short:d=4,o=5,b=100:16e6'
        - switch.turn_off: sntp_switch
        - if:
            condition:
              time.has_time:
                id: rtc_time
            then:
              - datetime.datetime.set:
                    id: custom_time
                    datetime: !lambda 'return id(rtc_time).now();'
        - lambda: |-
            setenv("TZ", id(time_zone)->state.c_str(), 1);
            tzset();
            struct tm time_info;
            auto *time = id(custom_time);
            time_info.tm_year = time->year - 1900;
            time_info.tm_mon = time->month - 1;
            time_info.tm_mday = time->day;
            time_info.tm_hour = time->hour;
            time_info.tm_min = time->minute + 1;
            time_info.tm_sec = time->second;
            time_info.tm_isdst = -1;
            std::time_t t = mktime(&time_info);
            struct timeval tv = {t, 0};
            settimeofday(&tv, NULL);
            ESP_LOGD("main", "System time set to: %s", ctime(&t));
        - pcf8563.write_time:
            id: rtc_time
        - datetime.datetime.set:
              id: custom_time
              datetime: !lambda |-
                  auto time = id(rtc_time).now();
                  return time;
        - logger.log: 
            format: "RTC incremented by 1 minute"
            level: INFO

  # Button to apply "Custom Time" text input to system
  - platform: template
    name: "Set Custom Time"
    id: custom_sync
    web_server:
      sorting_group_id: sorting_time
    on_press:
      then:
        - if:
            condition:
              - switch.is_off: sntp_switch
            then:
              - lambda: |-
                  setenv("TZ", id(time_zone)->state.c_str(), 1);
                  tzset();
                  struct tm time_info;
                  auto *time = id(custom_time);
                  time_info.tm_year = time->year - 1900;
                  time_info.tm_mon = time->month - 1;
                  time_info.tm_mday = time->day;
                  time_info.tm_hour = time->hour;
                  time_info.tm_min = time->minute;
                  time_info.tm_sec = time->second;
                  time_info.tm_isdst = -1;
                  std::time_t t = mktime(&time_info);
                  struct timeval tv = {t, 0};
                  settimeofday(&tv, NULL);
                  ESP_LOGD("main", "System time set to: %s", ctime(&t));
              - pcf8563.write_time:
                  id: rtc_time
              - logger.log: 
                  format: "RTC updated with custom time"
                  level: INFO
            else:
              - logger.log:
                  format: "Custom time NOT set - SNTP sync active"
                  level: WARN

  # Timer Controls
  - platform: template
    name: "Start Timer"
    id: start_timer_button
    web_server:
      sorting_group_id: sorting_timer
    on_press:
      then:
        - lambda: |-
            int h = (int)id(timer_hours).state;
            int m = (int)id(timer_minutes).state;
            int s = (int)id(timer_seconds).state;
            id(RingClock)->start_timer(h, m, s);
        - light.turn_on:
            id: ring_light
            effect: Timer

  - platform: template
    name: "Stop Timer & Stopwatch"
    id: stop_timer_button
    web_server:
      sorting_group_id: sorting_timer
    on_press:
      then:
        - lambda: 'id(RingClock)->stop_timer();'
        - light.turn_on:
            id: ring_light
            effect: Clock

  # Stopwatch Controls
  - platform: template
    name: "Start Stopwatch"
    id: start_stopwatch_button
    web_server:
      sorting_group_id: sorting_timer
    on_press:
      then:
        - lambda: 'id(RingClock)->start_stopwatch();'
        - light.turn_on:
            id: ring_light
            effect: Stopwatch

  - platform: template
    name: "Pause Stopwatch"
    id: pause_stopwatch_button
    web_server:
      sorting_group_id: sorting_timer
    on_press:
      then:
        - lambda: 'id(RingClock)->stop_stopwatch();'

  - platform: template
    name: "Reset Stopwatch"
    id: reset_stopwatch_button
    web_server:
      sorting_group_id: sorting_timer
    on_press:
      then:
        - lambda: 'id(RingClock)->reset_stopwatch();'

# Template numbers for Timer Input
number:
  - platform: template
    name: "Timer Hours"
    id: timer_hours
    min_value: 0
    max_value: 12
    step: 1
    initial_value: 0
    optimistic: True
    web_server:
      sorting_group_id: sorting_timer
  - platform: template
    name: "Timer Minutes"
    id: timer_minutes
    min_value: 0
    max_value: 59
    step: 1
    initial_value: 0
    optimistic: True
    web_server:
      sorting_group_id: sorting_timer
  - platform: template
    name: "Timer Seconds"
    id: timer_seconds
    min_value: 0
    max_value: 59
    step: 1
    initial_value: 0
    optimistic: True
    web_server:
      sorting_group_id: sorting_timer

